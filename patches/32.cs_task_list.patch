diff --git a/src/task_list/time_integrator.cpp b/src/task_list/time_integrator.cpp
index 097afa53..b997e1fe 100644
--- a/src/task_list/time_integrator.cpp
+++ b/src/task_list/time_integrator.cpp
@@ -36,6 +36,9 @@
 #include "../scalars/scalars.hpp"
 #include "task_list.hpp"
 
+// canoe injection
+#include <configure.hpp>
+
 //----------------------------------------------------------------------------------------
 //! TimeIntegratorTaskList constructor
 
@@ -998,6 +1001,14 @@ TimeIntegratorTaskList::TimeIntegratorTaskList(ParameterInput *pin, Mesh *pm) {
       AddTask(SEND_HYD,src_aterm);
       AddTask(RECV_HYD,NONE);
       AddTask(SETB_HYD,(RECV_HYD|SRC_TERM));
+
+#ifdef CUBED_SPHERE
+      //AddTask(CLEAR_ALLBND2, SETB_HYD);
+      AddTask(SEND_HYD2, SETB_HYD);
+      AddTask(CLEAR_ALLBND2, SEND_HYD2);
+      AddTask(RECV_HYD2, CLEAR_ALLBND2);
+      AddTask(SETB_HYD2, RECV_HYD2);
+#endif  // CUBED_SPHERE
     }
 
     if (SHEAR_PERIODIC) {
@@ -1156,9 +1167,17 @@ TimeIntegratorTaskList::TimeIntegratorTaskList(ParameterInput *pin, Mesh *pm) {
           }
         } else {
           if (NSCALARS > 0) {
+#ifdef CUBED_SPHERE
+            AddTask(CONS2PRIM,(SETB_HYD2|SETB_SCLR));
+#else
             AddTask(CONS2PRIM,(SETB_HYD|SETB_SCLR));
+#endif  // CUBED_SPHERE
           } else {
+#ifdef CUBED_SPHERE
+            AddTask(CONS2PRIM,SETB_HYD2);
+#else
             AddTask(CONS2PRIM,SETB_HYD);
+#endif  // CUBED_SPHERE
           }
         }
       }
@@ -1224,7 +1243,7 @@ void TimeIntegratorTaskList::AddTask(const TaskID& id, const TaskID& dep) {
   //!   SRC_TERM and SourceTerms(), USERWORK, PHY_BVAL, PROLONG, CONS2PRIM,
   //!   ... Although, AMR_FLAG = "flag blocks for AMR" should be FLAG_AMR in VERB_OBJECT
   using namespace HydroIntegratorTaskNames; // NOLINT (build/namespace)
-  if (id == CLEAR_ALLBND) {
+  if (id == CLEAR_ALLBND or id == CLEAR_ALLBND2) {
     task_list_[ntasks].TaskFunc=
         static_cast<TaskStatus (TaskList::*)(MeshBlock*,int)>
         (&TimeIntegratorTaskList::ClearAllBoundary);
@@ -1274,7 +1293,7 @@ void TimeIntegratorTaskList::AddTask(const TaskID& id, const TaskID& dep) {
         static_cast<TaskStatus (TaskList::*)(MeshBlock*,int)>
         (&TimeIntegratorTaskList::AddSourceTerms);
     task_list_[ntasks].lb_time = true;
-  } else if (id == SEND_HYD) {
+  } else if (id == SEND_HYD or id == SEND_HYD2) {
     task_list_[ntasks].TaskFunc=
         static_cast<TaskStatus (TaskList::*)(MeshBlock*,int)>
         (&TimeIntegratorTaskList::SendHydro);
@@ -1284,7 +1303,7 @@ void TimeIntegratorTaskList::AddTask(const TaskID& id, const TaskID& dep) {
         static_cast<TaskStatus (TaskList::*)(MeshBlock*,int)>
         (&TimeIntegratorTaskList::SendField);
     task_list_[ntasks].lb_time = true;
-  } else if (id == RECV_HYD) {
+  } else if (id == RECV_HYD or id == RECV_HYD2) {
     task_list_[ntasks].TaskFunc=
         static_cast<TaskStatus (TaskList::*)(MeshBlock*,int)>
         (&TimeIntegratorTaskList::ReceiveHydro);
@@ -1294,7 +1313,7 @@ void TimeIntegratorTaskList::AddTask(const TaskID& id, const TaskID& dep) {
         static_cast<TaskStatus (TaskList::*)(MeshBlock*,int)>
         (&TimeIntegratorTaskList::ReceiveField);
     task_list_[ntasks].lb_time = false;
-  } else if (id == SETB_HYD) {
+  } else if (id == SETB_HYD or id == SETB_HYD2) {
     task_list_[ntasks].TaskFunc=
         static_cast<TaskStatus (TaskList::*)(MeshBlock*,int)>
         (&TimeIntegratorTaskList::SetBoundariesHydro);
@@ -1963,6 +1982,8 @@ TaskStatus TimeIntegratorTaskList::DiffuseField(MeshBlock *pmb, int stage) {
 //! Functions to communicate Hydro variables between MeshBlocks
 
 TaskStatus TimeIntegratorTaskList::SendHydro(MeshBlock *pmb, int stage) {
+  if (Globals::my_rank == 0)
+    std::cout << "I'm send hydro" << std::endl;
   if (stage <= nstages) {
     // Swap Hydro quantity in BoundaryVariable interface back to conserved var formulation
     // (also needed in SetBoundariesHydro(), since the tasks are independent)
@@ -1990,6 +2011,8 @@ TaskStatus TimeIntegratorTaskList::SendField(MeshBlock *pmb, int stage) {
 //! Functions to receive Hydro variables between MeshBlocks
 
 TaskStatus TimeIntegratorTaskList::ReceiveHydro(MeshBlock *pmb, int stage) {
+  if (Globals::my_rank == 0)
+    std::cout << "I'm receive hydro" << std::endl;
   bool ret;
   if (stage <= nstages) {
     ret = pmb->phydro->hbvar.ReceiveBoundaryBuffers();
@@ -2024,6 +2047,8 @@ TaskStatus TimeIntegratorTaskList::ReceiveField(MeshBlock *pmb, int stage) {
 //! Functions to set Hydro boundaries
 
 TaskStatus TimeIntegratorTaskList::SetBoundariesHydro(MeshBlock *pmb, int stage) {
+  if (Globals::my_rank == 0)
+    std::cout << "I'm set boundary" << std::endl;
   if (stage <= nstages) {
     pmb->phydro->hbvar.SwapHydroQuantity(pmb->phydro->u, HydroBoundaryQuantity::cons);
     pmb->phydro->hbvar.SetBoundaries();
@@ -2193,6 +2218,8 @@ TaskStatus TimeIntegratorTaskList::Prolongation(MeshBlock *pmb, int stage) {
 
 
 TaskStatus TimeIntegratorTaskList::Primitives(MeshBlock *pmb, int stage) {
+  if (Globals::my_rank == 0)
+    std::cout << "I'm in Primitives" << std::endl;
   Hydro *ph = pmb->phydro;
   Field *pf = pmb->pfield;
   PassiveScalars *ps = pmb->pscalars;
diff --git a/src/task_list/task_list.hpp b/src/task_list/task_list.hpp
index fab49508..d39f85a6 100644
--- a/src/task_list/task_list.hpp
+++ b/src/task_list/task_list.hpp
@@ -401,5 +401,10 @@ const TaskID RECV_RADSH(74);
 
 const TaskID SRCTERM_IMRAD(75);
 
+const TaskID SEND_HYD2(76);
+const TaskID RECV_HYD2(77);
+const TaskID SETB_HYD2(78);
+const TaskID CLEAR_ALLBND2(79);
+
 }  // namespace HydroIntegratorTaskNames
 #endif  // TASK_LIST_TASK_LIST_HPP_
